Timer unit: 1e-06 s

Total time: 0.951742 s
File: <ipython-input-18-7d15925b3504>
Function: new_transition at line 4

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     4                                           def new_transition(state, state_1, w, r, sweep_size, _basis, _n_conns, _x_prime, _acting_on, _ad2o_o, _ad2_bool):
     5                                               '''
     6                                               This transition is exclusively for batch_size = 1
     7                                               '''
     8                                           
     9         1          2.0      2.0      0.0      accepted = 0
    10         1          2.0      2.0      0.0      batch_size = state.shape[0]
    11         1          1.0      1.0      0.0      sys_size = state.shape[-1]
    12                                           
    13         1          1.0      1.0      0.0      assert batch_size == 1, 'batch_size must be 1'
    14                                           
    15         1          5.0      5.0      0.0      sections = np.zeros(1, dtype=np.int64)
    16         1          3.0      3.0      0.0      sections_1 = np.zeros(1, dtype=np.int64)
    17         1          1.0      1.0      0.0      state_1 = state
    18                                           
    19         1         99.0     99.0      0.0      log_values = _log_val_kernel(state.astype(np.float64), w, r)[0]
    20                                               
    21                                           
    22         1         84.0     84.0      0.0      state_prime = np.zeros((int(sys_size/4), sys_size), dtype=np.int32)
    23         1         21.0     21.0      0.0      state_1_prime = np.zeros((int(sys_size/4), sys_size), dtype=np.int32)
    24         1         30.0     30.0      0.0      state_prime[:] = state
    25                                               
    26                                               
    27         1          4.0      4.0      0.0      conn_op_prime = np.zeros(int(sys_size/4), dtype=np.int32)
    28         1          3.0      3.0      0.0      conn_op_prime_1 = np.zeros(int(sys_size/4), dtype=np.int32)
    29                                               
    30                                           
    31         1          9.0      9.0      0.0      op_labels = np.arange(len(_acting_on))
    32                                           #     print(state_prime.shape)
    33         2        112.0     56.0      0.0      conn_op_prime[:] = local_kernel.get_conn_one_2(
    34         1          1.0      1.0      0.0                                      state, sections,_basis,_n_conns,_x_prime,_acting_on, op_labels, state_prime)
    35                                               
    36                                           
    37                                               
    38         1          2.0      2.0      0.0      n_conn = sections[0]
    39         1          1.0      1.0      0.0      n_conn_1 = n_conn
    40                                                   
    41                                               
    42                                               
    43         1         11.0     11.0      0.0      np.random.seed(2021)
    44                                           
    45         1          1.0      1.0      0.0      N = 0
    46     11951       6249.0      0.5      0.7      for kk in range(sweep_size * 2):
    47                                           #         print(kk)
    48                                           
    49                                           #         print(f'conn_op_prime (this is labels of flippable operators in last op_labels) = {conn_op_prime}')
    50                                           #         print(f"n_conn = {n_conn}")
    51                                                   
    52     11951      34434.0      2.9      3.6          rs = (np.random.rand(1)[0] * 4).astype(np.int64)
    53     11951       8903.0      0.7      0.9          op_label = conn_op_prime[rs] # choose operator label randomly. and flip the plaquete the choosen operator acting on.
    54     11951       8579.0      0.7      0.9          op_labels = _ad2o_o[op_label] # list up all adjacent operators to choosen operator.
    55     11951      20451.0      1.7      2.1          state_1 = state_prime[rs].reshape(1,-1).copy() # new candidate state
    56     11951       8555.0      0.7      0.9          op_label_bool = _ad2_bool[op_label]
    57                                                   
    58                                           
    59     23902      92396.0      3.9      9.7          local_kernel.get_conn_one_3(
    60     11951       6144.0      0.5      0.6                                      state_1, sections,_basis,_n_conns,
    61     11951       5878.0      0.5      0.6                                      _x_prime,_acting_on, op_labels, state_1_prime,
    62     11951       5890.0      0.5      0.6                                      conn_op_prime, conn_op_prime_1, op_label_bool, n_conn)
    63                                           
    64     11951       8203.0      0.7      0.9          n_conn_1 = sections[0]
    65                                           
    66     11951       7952.0      0.7      0.8          prob_corr = n_conn/n_conn_1
    67                                           
    68                                           
    69     11951     551927.0     46.2     58.0          log_values_1 = _log_val_kernel(state_1.astype(np.float64), w, r)[0]
    70                                           
    71     35853      41997.0      1.2      4.4          prob = np.exp(
    72     11951      11172.0      0.9      1.2              2 * (log_values_1 - log_values)
    73     11951       6349.0      0.5      0.7          ) * prob_corr
    74                                           
    75     11951      30996.0      2.6      3.3          if prob > np.random.rand(1):
    76                                           
    77     10000      12770.0      1.3      1.3              state[:] = state_1
    78     10000      42446.0      4.2      4.5              state_prime[:] = state_1_prime
    79     10000       9675.0      1.0      1.0              conn_op_prime[:] = conn_op_prime_1
    80                                           
    81     10000       5958.0      0.6      0.6              log_values = log_values_1
    82     10000       5519.0      0.6      0.6              n_conn = n_conn_1
    83     10000       5905.0      0.6      0.6              accepted += 1
    84                                                   
    85                                           #         else:
    86                                           #             print("YO?")
    87                                                       
    88                                           #         print("-" * 20)
    89                                           #         print("\n\n")
    90                                           
    91     11951       6652.0      0.6      0.7          N += 1
    92     11951       6348.0      0.5      0.7          if accepted >= sweep_size:
    93         1          0.0      0.0      0.0              break
    94                                           
    95         1          1.0      1.0      0.0      return accepted/N