Timer unit: 1e-06 s

Total time: 0.477802 s
File: <ipython-input-170-d5270e39c933>
Function: new_transition_2 at line 3

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           def new_transition_2(state, state_1, w , r, sweep_size, _basis, _n_conns, _x_prime, _acting_on, _ad2o_o, _ad2_bool):
     4                                               '''
     5                                               This transition is exclusively for batch_size = 1
     6                                               w_ :  w_acting_on(w, _acting_on)
     7                                               '''
     8                                           
     9         1          2.0      2.0      0.0      accepted = 0
    10         1          3.0      3.0      0.0      sys_size = state.shape[0]
    11                                           #     _w =  w_acting_on(w, _acting_on[:,1:3])
    12                                           
    13                                           
    14         1          7.0      7.0      0.0      sections = np.zeros(1, dtype=np.int64)
    15         1          3.0      3.0      0.0      sections_1 = np.zeros(1, dtype=np.int64)
    16         1         10.0     10.0      0.0      state_1[:] = state
    17                                               
    18         1          9.0      9.0      0.0      r_prime = np.zeros(w.shape[1], dtype = np.float64)
    19         1          6.0      6.0      0.0      r_prime_1 = np.zeros(w.shape[1], dtype = np.float64)
    20                                               
    21         1        141.0    141.0      0.0      log_values = _new_log_val_kernel_1(state.astype(np.float64), w, r_prime)
    22                                               
    23                                           #     w_ = w_acting_on(w, _acting_on)
    24                                           
    25         1        164.0    164.0      0.0      state_prime = np.zeros((int(sys_size/4), sys_size), dtype=np.int32)
    26                                               
    27                                               
    28         1          5.0      5.0      0.0      conn_op_prime = np.zeros(int(sys_size/4), dtype=np.int32)
    29         1          3.0      3.0      0.0      conn_op_prime_1 = np.zeros(int(sys_size/4), dtype=np.int32)
    30                                               
    31         1          5.0      5.0      0.0      acting_on_prime = np.zeros((int(sys_size/4), 4), dtype=np.int32)
    32         1          5.0      5.0      0.0      acting_on_prime_1 = np.zeros((int(sys_size/4), 4), dtype=np.int32)
    33                                               
    34                                               
    35                                               
    36         1         10.0     10.0      0.0      op_labels = np.arange(len(_acting_on))
    37         2        101.0     50.5      0.0      conn_op_prime[:] = local_kernel.get_conn_one_4(
    38         1          1.0      1.0      0.0                                      state, sections,_basis,_n_conns,_acting_on, op_labels, acting_on_prime)
    39                                           
    40                                               
    41         1          3.0      3.0      0.0      n_conn = sections[0]
    42         1          1.0      1.0      0.0      n_conn_1 = n_conn
    43                                                   
    44         1         14.0     14.0      0.0      np.random.seed(2021)
    45         1          1.0      1.0      0.0      last_state = state
    46                                           
    47         1          1.0      1.0      0.0      N = 0
    48         1          1.0      1.0      0.0      last_picked = 0
    49     11949       6737.0      0.6      1.4      for kk in range(sweep_size * 2):
    50                                           
    51                                           #         print(state)
    52                                           
    53                                                   
    54     11949      27232.0      2.3      5.7          rs = (np.random.rand(1)[0] * n_conn).astype(np.int64)
    55     11949       8797.0      0.7      1.8          op_label = conn_op_prime[rs] # choose operator label randomly. and flip the plaquete the choosen operator acting on.
    56                                           #         w_prime = _w[op_label]
    57     11949       8872.0      0.7      1.9          op_labels = _ad2o_o[op_label] # list up all adjacent operators to choosen operator.
    58     11949       6224.0      0.5      1.3          state_old = state
    59     11949      10054.0      0.8      2.1          state_1[:] = state
    60                                           #         print(rs)
    61                                           #         print(r_prime[:10])
    62     11949      10508.0      0.9      2.2          acting_on_rs = acting_on_prime[rs][1:3]
    63                                           #         print(state_1)
    64     11949      32411.0      2.7      6.8          state_1[acting_on_rs[0]] *= -1
    65     11949      28136.0      2.4      5.9          state_1[acting_on_rs[1]] *= -1
    66                                               
    67     11949     113585.0      9.5     23.8          log_values_1 = _new_log_val_kernel_2(state_1.astype(np.float64), w, r_prime, r_prime_1, acting_on_rs)
    68                                                   
    69                                                   
    70     11949       9597.0      0.8      2.0          op_label_bool = _ad2_bool[op_label] 
    71     23898      42893.0      1.8      9.0          local_kernel.get_conn_one_5(
    72     11949       6442.0      0.5      1.3                                      state_1, sections,_basis,_n_conns,
    73     11949       6160.0      0.5      1.3                                      _acting_on, op_labels,conn_op_prime,
    74     11949       6197.0      0.5      1.3                                       conn_op_prime_1,acting_on_prime_1, op_label_bool, n_conn)
    75     11949       8143.0      0.7      1.7          n_conn_1 = sections[0]
    76     11949       8121.0      0.7      1.7          prob_corr = n_conn/n_conn_1
    77                                           
    78                                                   
    79                                           #         print(r_prime)
    80                                           
    81     35847      29853.0      0.8      6.2          prob = np.exp(
    82     11949       7577.0      0.6      1.6              2 * (log_values_1 - log_values)
    83     11949       6542.0      0.5      1.4          ) * prob_corr
    84                                           
    85     11949      25330.0      2.1      5.3          if prob > np.random.rand(1):
    86     10000      10686.0      1.1      2.2              r_prime[:] = r_prime_1
    87     10000       8452.0      0.8      1.8              state[:] = state_1
    88     10000       9820.0      1.0      2.1              acting_on_prime[:] = acting_on_prime_1
    89     10000       8170.0      0.8      1.7              conn_op_prime[:] = conn_op_prime_1
    90                                           
    91     10000       5682.0      0.6      1.2              log_values = log_values_1
    92     10000       5801.0      0.6      1.2              n_conn = n_conn_1
    93     10000       5914.0      0.6      1.2              accepted += 1
    94                                                   
    95                                           
    96     11949       6796.0      0.6      1.4          N += 1
    97     11949       6573.0      0.6      1.4          if accepted >= sweep_size:
    98         1          0.0      0.0      0.0              break
    99                                                   
   100         1          1.0      1.0      0.0      return accepted/N